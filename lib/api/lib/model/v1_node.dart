//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//
// @dart=2.18

// ignore_for_file: unused_element, unused_import
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: constant_identifier_names
// ignore_for_file: lines_longer_than_80_chars

part of openapi.api;

class V1Node {
  /// Returns a new [V1Node] instance.
  V1Node({
    this.type,
    this.lineBreakNode,
    this.paragraphNode,
    this.codeBlockNode,
    this.headingNode,
    this.horizontalRuleNode,
    this.blockquoteNode,
    this.listNode,
    this.orderedListItemNode,
    this.unorderedListItemNode,
    this.taskListItemNode,
    this.mathBlockNode,
    this.tableNode,
    this.embeddedContentNode,
    this.textNode,
    this.boldNode,
    this.italicNode,
    this.boldItalicNode,
    this.codeNode,
    this.imageNode,
    this.linkNode,
    this.autoLinkNode,
    this.tagNode,
    this.strikethroughNode,
    this.escapingCharacterNode,
    this.mathNode,
    this.highlightNode,
    this.subscriptNode,
    this.superscriptNode,
    this.referencedContentNode,
    this.spoilerNode,
    this.htmlElementNode,
  });

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1NodeType? type;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  Object? lineBreakNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1ParagraphNode? paragraphNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1CodeBlockNode? codeBlockNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1HeadingNode? headingNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1HorizontalRuleNode? horizontalRuleNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1BlockquoteNode? blockquoteNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1ListNode? listNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1OrderedListItemNode? orderedListItemNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1UnorderedListItemNode? unorderedListItemNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1TaskListItemNode? taskListItemNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1MathBlockNode? mathBlockNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1TableNode? tableNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1EmbeddedContentNode? embeddedContentNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1TextNode? textNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1BoldNode? boldNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1ItalicNode? italicNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1BoldItalicNode? boldItalicNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1CodeNode? codeNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1ImageNode? imageNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1LinkNode? linkNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1AutoLinkNode? autoLinkNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1TagNode? tagNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1StrikethroughNode? strikethroughNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1EscapingCharacterNode? escapingCharacterNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1MathNode? mathNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1HighlightNode? highlightNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1SubscriptNode? subscriptNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1SuperscriptNode? superscriptNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1ReferencedContentNode? referencedContentNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1SpoilerNode? spoilerNode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  V1HTMLElementNode? htmlElementNode;

  @override
  bool operator ==(Object other) => identical(this, other) || other is V1Node &&
    other.type == type &&
    other.lineBreakNode == lineBreakNode &&
    other.paragraphNode == paragraphNode &&
    other.codeBlockNode == codeBlockNode &&
    other.headingNode == headingNode &&
    other.horizontalRuleNode == horizontalRuleNode &&
    other.blockquoteNode == blockquoteNode &&
    other.listNode == listNode &&
    other.orderedListItemNode == orderedListItemNode &&
    other.unorderedListItemNode == unorderedListItemNode &&
    other.taskListItemNode == taskListItemNode &&
    other.mathBlockNode == mathBlockNode &&
    other.tableNode == tableNode &&
    other.embeddedContentNode == embeddedContentNode &&
    other.textNode == textNode &&
    other.boldNode == boldNode &&
    other.italicNode == italicNode &&
    other.boldItalicNode == boldItalicNode &&
    other.codeNode == codeNode &&
    other.imageNode == imageNode &&
    other.linkNode == linkNode &&
    other.autoLinkNode == autoLinkNode &&
    other.tagNode == tagNode &&
    other.strikethroughNode == strikethroughNode &&
    other.escapingCharacterNode == escapingCharacterNode &&
    other.mathNode == mathNode &&
    other.highlightNode == highlightNode &&
    other.subscriptNode == subscriptNode &&
    other.superscriptNode == superscriptNode &&
    other.referencedContentNode == referencedContentNode &&
    other.spoilerNode == spoilerNode &&
    other.htmlElementNode == htmlElementNode;

  @override
  int get hashCode =>
    // ignore: unnecessary_parenthesis
    (type == null ? 0 : type!.hashCode) +
    (lineBreakNode == null ? 0 : lineBreakNode!.hashCode) +
    (paragraphNode == null ? 0 : paragraphNode!.hashCode) +
    (codeBlockNode == null ? 0 : codeBlockNode!.hashCode) +
    (headingNode == null ? 0 : headingNode!.hashCode) +
    (horizontalRuleNode == null ? 0 : horizontalRuleNode!.hashCode) +
    (blockquoteNode == null ? 0 : blockquoteNode!.hashCode) +
    (listNode == null ? 0 : listNode!.hashCode) +
    (orderedListItemNode == null ? 0 : orderedListItemNode!.hashCode) +
    (unorderedListItemNode == null ? 0 : unorderedListItemNode!.hashCode) +
    (taskListItemNode == null ? 0 : taskListItemNode!.hashCode) +
    (mathBlockNode == null ? 0 : mathBlockNode!.hashCode) +
    (tableNode == null ? 0 : tableNode!.hashCode) +
    (embeddedContentNode == null ? 0 : embeddedContentNode!.hashCode) +
    (textNode == null ? 0 : textNode!.hashCode) +
    (boldNode == null ? 0 : boldNode!.hashCode) +
    (italicNode == null ? 0 : italicNode!.hashCode) +
    (boldItalicNode == null ? 0 : boldItalicNode!.hashCode) +
    (codeNode == null ? 0 : codeNode!.hashCode) +
    (imageNode == null ? 0 : imageNode!.hashCode) +
    (linkNode == null ? 0 : linkNode!.hashCode) +
    (autoLinkNode == null ? 0 : autoLinkNode!.hashCode) +
    (tagNode == null ? 0 : tagNode!.hashCode) +
    (strikethroughNode == null ? 0 : strikethroughNode!.hashCode) +
    (escapingCharacterNode == null ? 0 : escapingCharacterNode!.hashCode) +
    (mathNode == null ? 0 : mathNode!.hashCode) +
    (highlightNode == null ? 0 : highlightNode!.hashCode) +
    (subscriptNode == null ? 0 : subscriptNode!.hashCode) +
    (superscriptNode == null ? 0 : superscriptNode!.hashCode) +
    (referencedContentNode == null ? 0 : referencedContentNode!.hashCode) +
    (spoilerNode == null ? 0 : spoilerNode!.hashCode) +
    (htmlElementNode == null ? 0 : htmlElementNode!.hashCode);

  @override
  String toString() => 'V1Node[type=$type, lineBreakNode=$lineBreakNode, paragraphNode=$paragraphNode, codeBlockNode=$codeBlockNode, headingNode=$headingNode, horizontalRuleNode=$horizontalRuleNode, blockquoteNode=$blockquoteNode, listNode=$listNode, orderedListItemNode=$orderedListItemNode, unorderedListItemNode=$unorderedListItemNode, taskListItemNode=$taskListItemNode, mathBlockNode=$mathBlockNode, tableNode=$tableNode, embeddedContentNode=$embeddedContentNode, textNode=$textNode, boldNode=$boldNode, italicNode=$italicNode, boldItalicNode=$boldItalicNode, codeNode=$codeNode, imageNode=$imageNode, linkNode=$linkNode, autoLinkNode=$autoLinkNode, tagNode=$tagNode, strikethroughNode=$strikethroughNode, escapingCharacterNode=$escapingCharacterNode, mathNode=$mathNode, highlightNode=$highlightNode, subscriptNode=$subscriptNode, superscriptNode=$superscriptNode, referencedContentNode=$referencedContentNode, spoilerNode=$spoilerNode, htmlElementNode=$htmlElementNode]';

  Map<String, dynamic> toJson() {
    final json = <String, dynamic>{};
    if (this.type != null) {
      json[r'type'] = this.type;
    } else {
      json[r'type'] = null;
    }
    if (this.lineBreakNode != null) {
      json[r'lineBreakNode'] = this.lineBreakNode;
    } else {
      json[r'lineBreakNode'] = null;
    }
    if (this.paragraphNode != null) {
      json[r'paragraphNode'] = this.paragraphNode;
    } else {
      json[r'paragraphNode'] = null;
    }
    if (this.codeBlockNode != null) {
      json[r'codeBlockNode'] = this.codeBlockNode;
    } else {
      json[r'codeBlockNode'] = null;
    }
    if (this.headingNode != null) {
      json[r'headingNode'] = this.headingNode;
    } else {
      json[r'headingNode'] = null;
    }
    if (this.horizontalRuleNode != null) {
      json[r'horizontalRuleNode'] = this.horizontalRuleNode;
    } else {
      json[r'horizontalRuleNode'] = null;
    }
    if (this.blockquoteNode != null) {
      json[r'blockquoteNode'] = this.blockquoteNode;
    } else {
      json[r'blockquoteNode'] = null;
    }
    if (this.listNode != null) {
      json[r'listNode'] = this.listNode;
    } else {
      json[r'listNode'] = null;
    }
    if (this.orderedListItemNode != null) {
      json[r'orderedListItemNode'] = this.orderedListItemNode;
    } else {
      json[r'orderedListItemNode'] = null;
    }
    if (this.unorderedListItemNode != null) {
      json[r'unorderedListItemNode'] = this.unorderedListItemNode;
    } else {
      json[r'unorderedListItemNode'] = null;
    }
    if (this.taskListItemNode != null) {
      json[r'taskListItemNode'] = this.taskListItemNode;
    } else {
      json[r'taskListItemNode'] = null;
    }
    if (this.mathBlockNode != null) {
      json[r'mathBlockNode'] = this.mathBlockNode;
    } else {
      json[r'mathBlockNode'] = null;
    }
    if (this.tableNode != null) {
      json[r'tableNode'] = this.tableNode;
    } else {
      json[r'tableNode'] = null;
    }
    if (this.embeddedContentNode != null) {
      json[r'embeddedContentNode'] = this.embeddedContentNode;
    } else {
      json[r'embeddedContentNode'] = null;
    }
    if (this.textNode != null) {
      json[r'textNode'] = this.textNode;
    } else {
      json[r'textNode'] = null;
    }
    if (this.boldNode != null) {
      json[r'boldNode'] = this.boldNode;
    } else {
      json[r'boldNode'] = null;
    }
    if (this.italicNode != null) {
      json[r'italicNode'] = this.italicNode;
    } else {
      json[r'italicNode'] = null;
    }
    if (this.boldItalicNode != null) {
      json[r'boldItalicNode'] = this.boldItalicNode;
    } else {
      json[r'boldItalicNode'] = null;
    }
    if (this.codeNode != null) {
      json[r'codeNode'] = this.codeNode;
    } else {
      json[r'codeNode'] = null;
    }
    if (this.imageNode != null) {
      json[r'imageNode'] = this.imageNode;
    } else {
      json[r'imageNode'] = null;
    }
    if (this.linkNode != null) {
      json[r'linkNode'] = this.linkNode;
    } else {
      json[r'linkNode'] = null;
    }
    if (this.autoLinkNode != null) {
      json[r'autoLinkNode'] = this.autoLinkNode;
    } else {
      json[r'autoLinkNode'] = null;
    }
    if (this.tagNode != null) {
      json[r'tagNode'] = this.tagNode;
    } else {
      json[r'tagNode'] = null;
    }
    if (this.strikethroughNode != null) {
      json[r'strikethroughNode'] = this.strikethroughNode;
    } else {
      json[r'strikethroughNode'] = null;
    }
    if (this.escapingCharacterNode != null) {
      json[r'escapingCharacterNode'] = this.escapingCharacterNode;
    } else {
      json[r'escapingCharacterNode'] = null;
    }
    if (this.mathNode != null) {
      json[r'mathNode'] = this.mathNode;
    } else {
      json[r'mathNode'] = null;
    }
    if (this.highlightNode != null) {
      json[r'highlightNode'] = this.highlightNode;
    } else {
      json[r'highlightNode'] = null;
    }
    if (this.subscriptNode != null) {
      json[r'subscriptNode'] = this.subscriptNode;
    } else {
      json[r'subscriptNode'] = null;
    }
    if (this.superscriptNode != null) {
      json[r'superscriptNode'] = this.superscriptNode;
    } else {
      json[r'superscriptNode'] = null;
    }
    if (this.referencedContentNode != null) {
      json[r'referencedContentNode'] = this.referencedContentNode;
    } else {
      json[r'referencedContentNode'] = null;
    }
    if (this.spoilerNode != null) {
      json[r'spoilerNode'] = this.spoilerNode;
    } else {
      json[r'spoilerNode'] = null;
    }
    if (this.htmlElementNode != null) {
      json[r'htmlElementNode'] = this.htmlElementNode;
    } else {
      json[r'htmlElementNode'] = null;
    }
    return json;
  }

  /// Returns a new [V1Node] instance and imports its values from
  /// [value] if it's a [Map], null otherwise.
  // ignore: prefer_constructors_over_static_methods
  static V1Node? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      // Ensure that the map contains the required keys.
      // Note 1: the values aren't checked for validity beyond being non-null.
      // Note 2: this code is stripped in release mode!
      assert(() {
        requiredKeys.forEach((key) {
          assert(json.containsKey(key), 'Required key "V1Node[$key]" is missing from JSON.');
          assert(json[key] != null, 'Required key "V1Node[$key]" has a null value in JSON.');
        });
        return true;
      }());

      return V1Node(
        type: V1NodeType.fromJson(json[r'type']),
        lineBreakNode: mapValueOfType<Object>(json, r'lineBreakNode'),
        paragraphNode: V1ParagraphNode.fromJson(json[r'paragraphNode']),
        codeBlockNode: V1CodeBlockNode.fromJson(json[r'codeBlockNode']),
        headingNode: V1HeadingNode.fromJson(json[r'headingNode']),
        horizontalRuleNode: V1HorizontalRuleNode.fromJson(json[r'horizontalRuleNode']),
        blockquoteNode: V1BlockquoteNode.fromJson(json[r'blockquoteNode']),
        listNode: V1ListNode.fromJson(json[r'listNode']),
        orderedListItemNode: V1OrderedListItemNode.fromJson(json[r'orderedListItemNode']),
        unorderedListItemNode: V1UnorderedListItemNode.fromJson(json[r'unorderedListItemNode']),
        taskListItemNode: V1TaskListItemNode.fromJson(json[r'taskListItemNode']),
        mathBlockNode: V1MathBlockNode.fromJson(json[r'mathBlockNode']),
        tableNode: V1TableNode.fromJson(json[r'tableNode']),
        embeddedContentNode: V1EmbeddedContentNode.fromJson(json[r'embeddedContentNode']),
        textNode: V1TextNode.fromJson(json[r'textNode']),
        boldNode: V1BoldNode.fromJson(json[r'boldNode']),
        italicNode: V1ItalicNode.fromJson(json[r'italicNode']),
        boldItalicNode: V1BoldItalicNode.fromJson(json[r'boldItalicNode']),
        codeNode: V1CodeNode.fromJson(json[r'codeNode']),
        imageNode: V1ImageNode.fromJson(json[r'imageNode']),
        linkNode: V1LinkNode.fromJson(json[r'linkNode']),
        autoLinkNode: V1AutoLinkNode.fromJson(json[r'autoLinkNode']),
        tagNode: V1TagNode.fromJson(json[r'tagNode']),
        strikethroughNode: V1StrikethroughNode.fromJson(json[r'strikethroughNode']),
        escapingCharacterNode: V1EscapingCharacterNode.fromJson(json[r'escapingCharacterNode']),
        mathNode: V1MathNode.fromJson(json[r'mathNode']),
        highlightNode: V1HighlightNode.fromJson(json[r'highlightNode']),
        subscriptNode: V1SubscriptNode.fromJson(json[r'subscriptNode']),
        superscriptNode: V1SuperscriptNode.fromJson(json[r'superscriptNode']),
        referencedContentNode: V1ReferencedContentNode.fromJson(json[r'referencedContentNode']),
        spoilerNode: V1SpoilerNode.fromJson(json[r'spoilerNode']),
        htmlElementNode: V1HTMLElementNode.fromJson(json[r'htmlElementNode']),
      );
    }
    return null;
  }

  static List<V1Node> listFromJson(dynamic json, {bool growable = false,}) {
    final result = <V1Node>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = V1Node.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  static Map<String, V1Node> mapFromJson(dynamic json) {
    final map = <String, V1Node>{};
    if (json is Map && json.isNotEmpty) {
      json = json.cast<String, dynamic>(); // ignore: parameter_assignments
      for (final entry in json.entries) {
        final value = V1Node.fromJson(entry.value);
        if (value != null) {
          map[entry.key] = value;
        }
      }
    }
    return map;
  }

  // maps a json object with a list of V1Node-objects as value to a dart map
  static Map<String, List<V1Node>> mapListFromJson(dynamic json, {bool growable = false,}) {
    final map = <String, List<V1Node>>{};
    if (json is Map && json.isNotEmpty) {
      // ignore: parameter_assignments
      json = json.cast<String, dynamic>();
      for (final entry in json.entries) {
        map[entry.key] = V1Node.listFromJson(entry.value, growable: growable,);
      }
    }
    return map;
  }

  /// The list of required keys that must be present in a JSON.
  static const requiredKeys = <String>{
  };
}

