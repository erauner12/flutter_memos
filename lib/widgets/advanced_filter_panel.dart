import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
// No Material import needed anymore
import 'package:flutter_memos/providers/filter_providers.dart';
import 'package:flutter_memos/utils/filter_builder.dart';
import 'package:flutter_memos/utils/filter_presets.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Advanced filter panel that allows users to create complex filters
/// through both a visual interface and raw CEL expressions
class AdvancedFilterPanel extends ConsumerStatefulWidget {
  final VoidCallback onClose;

  const AdvancedFilterPanel({
    super.key, required this.onClose});

  @override
  ConsumerState<AdvancedFilterPanel> createState() => _AdvancedFilterPanelState();
}

class _AdvancedFilterPanelState extends ConsumerState<AdvancedFilterPanel> {
  // Controllers for filter inputs
  late TextEditingController _rawFilterController;
  // Add a ScrollController that will be properly disposed
  final ScrollController _scrollController = ScrollController();

  // Local state for filter builder (Simplified: remove time/status)
  bool _useVisibilityFilter = false;
  String _selectedVisibility = 'PUBLIC';
  bool _useTagFilter = false;
  String _tagInput = '';
  List<String> _selectedTags = [];
  bool _useContentFilter = false;
  String _contentFilter = '';
  // REMOVED: _useTimeFilter
  // REMOVED: _selectedTimeRange

  // State for syntax validation
  String _syntaxError = '';
  bool _isValid = true;

  // Currently selected filter preset (from this panel's presets)
  String? _selectedPreset; // Keep for the panel's own presets

  @override
  void initState() {
    super.initState();
    _rawFilterController = TextEditingController(
      // Initialize with current raw filter ONLY if the current preset is 'custom'
      text:
          ref.read(quickFilterPresetProvider) == 'custom'
              ? ref.read(rawCelFilterProvider)
              : '',
    );
    _rawFilterController.addListener(_validateFilter);

    // Initialize filter settings from current filter if possible (only if custom)
    if (ref.read(quickFilterPresetProvider) == 'custom') {
      _initializeFromCurrentFilter(ref.read(rawCelFilterProvider));
    }
    // Initial validation
    _validateFilter();
  }

  // Modified to accept the current filter string
  void _initializeFromCurrentFilter(String currentFilter) {
    // final currentFilter = ref.read(rawCelFilterProvider); // No longer read directly
    if (currentFilter.isEmpty) return;

    // Reset builder states before parsing
    _useVisibilityFilter = false;
    _useTagFilter = false;
    _selectedTags = [];
    _useContentFilter = false;
    _contentFilter = '';
    // Time filter state removed

    try {
      // Parse visibility
      if (currentFilter.contains('visibility ==') ||
          currentFilter.contains('visibility in')) {
        _useVisibilityFilter = true;
        if (currentFilter.contains('"PUBLIC"')) {
          _selectedVisibility = 'PUBLIC';
        } else if (currentFilter.contains('"PROTECTED"'))
          _selectedVisibility = 'PROTECTED';
        else if (currentFilter.contains('"PRIVATE"'))
          _selectedVisibility = 'PRIVATE';
      }

      // Parse tags
      if (currentFilter.contains('tag in')) {
        final tagMatch = RegExp(r'tag in \[(.*?)\]').firstMatch(currentFilter);
        if (tagMatch != null && tagMatch.group(1) != null) {
          _useTagFilter = true;
          final tagString = tagMatch.group(1)!;
          _selectedTags = tagString
                  .split(',')
              .map((tag) => tag.trim().replaceAll('"', ''))
              .where((tag) => tag.isNotEmpty)
                  .toList();
        }
      }

      // Parse content
      if (currentFilter.contains('content.contains')) {
        final contentMatch = RegExp(r'content.contains\("(.*?)"\)').firstMatch(currentFilter);
        if (contentMatch != null && contentMatch.group(1) != null) {
          _useContentFilter = true;
          _contentFilter = contentMatch.group(1)!;
        }
      }

      // Time filter parsing removed

    } catch (e) {
      if (kDebugMode) {
        print('[AdvancedFilterPanel] Error parsing filter: $e');
      }
      // Optionally reset builder state on error
    }
  }


  @override
  void dispose() {
    _rawFilterController.dispose();
    _scrollController.dispose(); // Dispose the ScrollController
    super.dispose();
  }

  void _validateFilter() {
    final filter = _rawFilterController.text;
    if (filter.isEmpty) {
      setState(() {
        _syntaxError = '';
        _isValid = true;
      });
      return;
    }

    // Use detailed validation
    final error = FilterBuilder.validateCelExpressionDetailed(filter);
    setState(() {
      _syntaxError = error;
      _isValid = error.isEmpty;
    });
  }

  // Apply filter generated by the builder UI
  void _buildAndApplyFilter() {
    setState(() {
      _selectedPreset = null; // Clear panel's preset selection
    });

    List<String> filterParts = [];

    if (_useVisibilityFilter) {
      filterParts.add(FilterBuilder.byVisibility(_selectedVisibility));
    }

    if (_useTagFilter && _selectedTags.isNotEmpty) {
      filterParts.add(FilterBuilder.byTags(_selectedTags));
    }

    if (_useContentFilter && _contentFilter.isNotEmpty) {
      filterParts.add(FilterBuilder.byContent(_contentFilter));
    }

    // Time filter builder removed

    String finalFilter = '';
    if (filterParts.isNotEmpty) {
      finalFilter = FilterBuilder.and(filterParts);
    }

    _rawFilterController.text = finalFilter;
    _validateFilter(); // Validate the built filter

    // Apply the generated filter (which also sets preset to 'custom')
    // Only apply if valid
    if (_isValid) {
      _applyFilter(finalFilter);
    } else {
      if (kDebugMode) {
        print(
          '[AdvancedFilterPanel] Builder generated invalid filter: $finalFilter',
        );
      }
      // Optionally show an error message to the user
    }
  }

  // Apply a filter (either from raw input, builder, or panel preset)
  void _applyFilter(String filter) {
    // Ensure the filter is valid before applying
    final error = FilterBuilder.validateCelExpressionDetailed(filter);
    if (error.isNotEmpty) {
      setState(() {
        _syntaxError = error;
        _isValid = false;
      });
      if (kDebugMode) {
        print('[AdvancedFilterPanel] Cannot apply invalid filter: $filter');
      }
      // Optionally show error dialog
      showCupertinoDialog(
        context: context,
        builder:
            (context) => CupertinoAlertDialog(
              title: const Text('Invalid Filter'),
              content: Text('The filter expression has errors:\n$error'),
              actions: [
                CupertinoDialogAction(
                  isDefaultAction: true,
                  child: const Text('OK'),
                  onPressed: () => Navigator.pop(context),
                ),
              ],
            ),
      );
      return;
    }

    // Update the raw filter provider
    ref.read(rawCelFilterProvider.notifier).state = filter;
    // Set the main screen's preset to 'custom' to indicate advanced filter is active
    ref.read(quickFilterPresetProvider.notifier).state = 'custom';

    // Trigger refresh (MemosNotifier should react)
    // ref.read(memosNotifierProvider.notifier).refresh(); // Not needed if notifier watches combinedFilterProvider

    // Close the panel after applying
    widget.onClose();

    // Optional: Show feedback (removed SnackBar/Dialog for brevity)
  }

  // Apply a preset *from this panel's list*
  void _applyPreset(String presetKey) {
    String filter = '';

    setState(() {
      _selectedPreset = presetKey; // Track selected preset within the panel
    });

    // Generate filter based on the panel's preset key
    switch (presetKey) {
      case 'today':
        filter = FilterPresets.todayFilter();
        break;
      case 'created_today':
        filter = FilterPresets.createdTodayFilter();
        break;
      case 'updated_today':
        filter = FilterPresets.updatedTodayFilter();
        break;
      case 'this_week':
        filter = FilterPresets.thisWeekFilter();
        break;
      case 'important':
        filter = FilterPresets.importantFilter();
        break;
      case 'untagged':
        filter = FilterPresets.untaggedFilter();
        break;
      case 'tagged':
        filter = FilterPresets.taggedFilter();
        break;
      case 'public':
        filter = 'visibility == "PUBLIC"';
        break;
      case 'private':
        filter = 'visibility == "PRIVATE"';
        break;
      // Add more panel-specific presets if needed
    }

    _rawFilterController.text = filter;
    _validateFilter(); // Validate the preset filter

    // Apply the generated filter (which also sets preset to 'custom')
    // Only apply if valid (presets should always be valid, but check anyway)
    if (_isValid) {
      _applyFilter(filter);
    }
  }

  // Reset filters within the panel and set main screen preset back to default
  void _resetFilters() {
    setState(() {
      // Reset builder state
      _useVisibilityFilter = false;
      _selectedVisibility = 'PUBLIC';
      _useTagFilter = false;
      _tagInput = '';
      _selectedTags = [];
      _useContentFilter = false;
      _contentFilter = '';
      // Time filter state removed
      _selectedPreset = null; // Clear panel's preset selection
    });

    // Clear the raw filter text field and validation state
    _rawFilterController.text = '';
    _validateFilter(); // Reset validation state

    // Clear the raw filter provider state
    ref.read(rawCelFilterProvider.notifier).state = '';
    // Reset the main screen's preset provider to default (e.g., 'inbox')
    ref.read(quickFilterPresetProvider.notifier).state =
        'inbox'; // Or your desired default

    // Trigger refresh (MemosNotifier should react)
    // ref.read(memosNotifierProvider.notifier).refresh(); // Not needed if notifier watches combinedFilterProvider

    // Close the panel
    widget.onClose();
  }


  void _addTag() {
    if (_tagInput.isEmpty) return;
    final tagToAdd = _tagInput.trim(); // Trim whitespace
    if (tagToAdd.isEmpty) return; // Don't add empty tags

    setState(() {
      if (!_selectedTags.contains(tagToAdd)) {
        _selectedTags.add(tagToAdd);
      }
      _tagInput = ''; // Clear input field
    });
    // Optionally rebuild & apply filter immediately, or wait for Apply Builder button
  }

  void _removeTag(String tag) {
    setState(() {
      _selectedTags.remove(tag);
    });
    // Optionally rebuild & apply filter immediately, or wait for Apply Builder button
  }

  @override
  Widget build(BuildContext context) {
    // Use CupertinoTheme for styling
    final theme = CupertinoTheme.of(context);
    // final isDarkMode = theme.brightness == Brightness.dark; // Unused

    // Use Cupertino dynamic colors
    final Color panelBackgroundColor = theme.scaffoldBackgroundColor;
    final Color handleColor = CupertinoColors.systemGrey4.resolveFrom(context);
    final Color separatorColor = CupertinoColors.separator.resolveFrom(context);
    final TextStyle titleStyle = theme.textTheme.navTitleTextStyle.copyWith(fontSize: 18);
    final TextStyle sectionHeaderStyle = theme.textTheme.textStyle.copyWith(
      fontSize: 16,
      fontWeight: FontWeight.bold,
      color: CupertinoColors.secondaryLabel.resolveFrom(context),
    );
    final Color textFieldBackgroundColor = CupertinoColors.secondarySystemFill.resolveFrom(context);
    final Color errorColor = CupertinoColors.systemRed.resolveFrom(context);
    final Color validBorderColor = separatorColor;
    final Color invalidBorderColor = errorColor;

    return Container(
      // Clip content to rounded corners
      clipBehavior: Clip.antiAlias,
      decoration: BoxDecoration(
        color: panelBackgroundColor,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(16),
          topRight: Radius.circular(16),
        ),
        boxShadow: [
          BoxShadow(
            color: CupertinoColors.black.withAlpha(38),
            blurRadius: 10,
            spreadRadius: 0,
          ),
        ],
      ),
      // Use SafeArea to avoid intrusions at the bottom (like home indicator)
      child: SafeArea(
        top: false, // No top padding needed as we handle it
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          mainAxisSize: MainAxisSize.min, // Make column height fit content
          children: [
            // Drag Handle
            Center(
              child: Container(
                margin: const EdgeInsets.only(
                  top: 8,
                  bottom: 8,
                ), // Adjust margin
                width: 40,
                height: 5,
                decoration: BoxDecoration(
                  color: handleColor,
                  borderRadius: BorderRadius.circular(2.5),
                ),
              ),
            ),
            // Header Row
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // Reset button on the left
                  CupertinoButton(
                    padding: EdgeInsets.zero,
                    onPressed: _resetFilters, // Call reset function
                    child: const Text('Reset'),
                  ),
                  // Title in the middle
                  Text('Advanced Filter', style: titleStyle),
                  // Done button on the right (acts like close)
                  CupertinoButton(
                    padding: EdgeInsets.zero,
                    onPressed: widget.onClose,
                    child: const Text(
                      'Done',
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                  ),
                ],
              ),
            ),
            // Separator
            Container(
              height: 0.5,
              color: separatorColor,
              margin: const EdgeInsets.symmetric(vertical: 8.0),
            ),
            // Scrollable Content Area
            Flexible(
              // Use Flexible instead of Expanded for DraggableScrollableSheet
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16.0),
                child: CupertinoScrollbar(
                  // Use CupertinoScrollbar
                  controller: _scrollController, // Attach the controller
                  thumbVisibility: true, // Make scrollbar always visible
                  child: SingleChildScrollView(
                    controller:
                        _scrollController, // Use the same controller here
                    physics: const AlwaysScrollableScrollPhysics(),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        // Filter Presets Section (Panel specific presets)
                        Text('Quick Presets', style: sectionHeaderStyle),
                        const SizedBox(height: 8),
                        Wrap(
                          spacing: 8,
                          runSpacing: 8,
                          children: [
                            _buildPresetChip('today', 'Today'),
                            _buildPresetChip('created_today', 'Created Today'),
                            _buildPresetChip('updated_today', 'Updated Today'),
                            _buildPresetChip('this_week', 'This Week'),
                            _buildPresetChip('important', 'Important'),
                            _buildPresetChip('untagged', 'Untagged'),
                            _buildPresetChip('tagged', 'Tagged'),
                            _buildPresetChip('public', 'Public'),
                            _buildPresetChip('private', 'Private'),
                          ],
                        ),
                        const SizedBox(height: 24),

                        // Build a Filter Section
                        Text('Build a Filter', style: sectionHeaderStyle),
                        // Visibility Filter
                        CupertinoListTile(
                          title: const Text('Filter by Visibility'),
                          trailing: CupertinoSwitch(
                            value: _useVisibilityFilter,
                            onChanged:
                                (value) => setState(
                                  () => _useVisibilityFilter = value,
                                ),
                          ),
                        ),
                        if (_useVisibilityFilter)
                          Padding(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 16,
                              vertical: 8,
                            ),
                            child: CupertinoSegmentedControl<String>(
                              children: const {
                                'PUBLIC': Padding(
                                  padding: EdgeInsets.symmetric(vertical: 6),
                                  child: Text('Public'),
                                ),
                                'PROTECTED': Padding(
                                  padding: EdgeInsets.symmetric(vertical: 6),
                                  child: Text('Protected'),
                                ),
                                'PRIVATE': Padding(
                                  padding: EdgeInsets.symmetric(vertical: 6),
                                  child: Text('Private'),
                                ),
                              },
                              groupValue: _selectedVisibility,
                              onValueChanged:
                                  (value) => setState(
                                    () => _selectedVisibility = value,
                                  ),
                            ),
                          ),
                        // Tag Filter
                        CupertinoListTile(
                          title: const Text('Filter by Tags'),
                          trailing: CupertinoSwitch(
                            value: _useTagFilter,
                            onChanged:
                                (value) =>
                                    setState(() => _useTagFilter = value),
                          ),
                        ),
                        if (_useTagFilter)
                          Padding(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 16,
                              vertical: 8,
                            ),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Row(
                                  children: [
                                    Expanded(
                                      child: CupertinoTextField(
                                        // Use a separate controller for the tag input field
                                        controller: TextEditingController(
                                          text: _tagInput,
                                        ),
                                        placeholder: 'Enter a tag',
                                        padding: const EdgeInsets.symmetric(
                                          horizontal: 12,
                                          vertical: 8,
                                        ),
                                        clearButtonMode:
                                            OverlayVisibilityMode.editing,
                                        onChanged:
                                            (value) =>
                                                _tagInput =
                                                    value, // Update state variable directly
                                        onSubmitted: (_) => _addTag(),
                                      ),
                                    ),
                                    const SizedBox(width: 8),
                                    CupertinoButton.filled(
                                      padding: const EdgeInsets.symmetric(
                                        horizontal: 16,
                                        vertical: 8,
                                      ),
                                      minSize: 0,
                                      onPressed: _addTag,
                                      child: const Text('Add'),
                                    ),
                                  ],
                                ),
                                const SizedBox(height: 8),
                                Wrap(
                                  spacing: 8,
                                  runSpacing: 4,
                                  children:
                                      _selectedTags
                                          .map((tag) => _buildTagChip(tag))
                                          .toList(),
                                ),
                              ],
                            ),
                          ),
                        // Content Filter
                        CupertinoListTile(
                          title: const Text('Filter by Content'),
                          trailing: CupertinoSwitch(
                            value: _useContentFilter,
                            onChanged:
                                (value) =>
                                    setState(() => _useContentFilter = value),
                          ),
                        ),
                        if (_useContentFilter)
                          Padding(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 16,
                              vertical: 8,
                            ),
                            child: CupertinoTextField(
                              placeholder: 'Content contains...',
                              padding: const EdgeInsets.symmetric(
                                horizontal: 12,
                                vertical: 8,
                              ),
                              clearButtonMode: OverlayVisibilityMode.editing,
                              // Use a separate controller for content filter
                              controller: TextEditingController(
                                  text: _contentFilter,
                                )
                                ..selection = TextSelection.collapsed(
                                  offset: _contentFilter.length,
                                ),
                              onChanged:
                                  (value) =>
                                      setState(() => _contentFilter = value),
                            ),
                          ),
                        // --- Add Hide Future Notes Toggle ---
                        Consumer(
                          builder: (context, ref, child) {
                            final hideFuture = ref.watch(
                              hideFutureStartDateProvider,
                            );
                            return CupertinoListTile(
                              title: const Text('Hide Future Notes'),
                              subtitle: const Text(
                                'Hide notes where start date is in the future',
                              ),
                              padding: const EdgeInsets.symmetric(
                                horizontal: 0,
                                vertical: 4,
                              ), // Adjust padding
                              trailing: CupertinoSwitch(
                                value: hideFuture,
                                onChanged: (value) {
                                  ref
                                      .read(
                                        hideFutureStartDateProvider.notifier,
                                      )
                                      .state = value;
                                },
                              ),
                            );
                          },
                        ),
                        // ------------------------------------
                        // REMOVED: Time Filter UI Section
                        const SizedBox(height: 16),
                        // Apply Builder Button
                        Center(
                          // Center the single button
                          child: CupertinoButton.filled(
                            onPressed: _buildAndApplyFilter,
                            child: const Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Icon(CupertinoIcons.checkmark_alt),
                                SizedBox(width: 4),
                                Text('Apply Builder & Close'),
                              ],
                            ),
                          ),
                        ),
                        // REMOVED: Reset Builder Button (handled by header Reset)
                        const SizedBox(height: 24),

                        // Raw CEL Filter Section
                        Text(
                          'Raw CEL Filter Expression',
                          style: sectionHeaderStyle,
                        ),
                        const SizedBox(height: 8),
                        Container(
                          padding: const EdgeInsets.all(8),
                          decoration: BoxDecoration(
                            color: textFieldBackgroundColor,
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(
                              color:
                                  _isValid
                                      ? validBorderColor
                                      : invalidBorderColor,
                              width: 0.5,
                            ),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              // Use SyntaxHighlightTextField (or CupertinoTextField if highlighting fails)
                              SyntaxHighlightTextField(
                                // Keep using this for now
                                controller: _rawFilterController,
                                placeholder: 'Enter a CEL filter expression...',
                                maxLines: 4,
                                style: TextStyle(
                                  fontFamily: 'monospace',
                                  fontSize: 14,
                                  color: CupertinoColors.label.resolveFrom(
                                    context,
                                  ),
                                ),
                                onChanged:
                                    (_) =>
                                        _validateFilter(), // Re-validate on change
                              ),
                              /* // Fallback to CupertinoTextField if needed
                              CupertinoTextField(
                                controller: _rawFilterController,
                                placeholder: 'Enter a CEL filter expression...',
                                keyboardType: TextInputType.multiline,
                                maxLines: 4,
                                style: TextStyle(
                                  fontFamily: 'monospace',
                                  fontSize: 14,
                                  color: CupertinoColors.label.resolveFrom(context),
                                ),
                                decoration: BoxDecoration( // Remove default border
                                  border: Border.all(color: CupertinoColors.transparent, width: 0),
                                ),
                                padding: EdgeInsets.zero, // Adjust padding as needed
                                onChanged: (_) => _validateFilter(), // Re-validate on change
                                autocorrect: false,
                                enableSuggestions: false,
                              ),
                              */
                              if (_syntaxError.isNotEmpty)
                                Padding(
                                  padding: const EdgeInsets.only(top: 8),
                                  child: Text(
                                    _syntaxError,
                                    style: TextStyle(
                                      color: errorColor,
                                      fontSize: 12,
                                    ),
                                  ),
                                ),
                            ],
                          ),
                        ),
                        const SizedBox(height: 8),
                        // Apply Raw Filter Button
                        Center(
                          child: CupertinoButton(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 16,
                              vertical: 8,
                            ),
                            // Apply the raw filter text and close
                            onPressed:
                                () => _applyFilter(_rawFilterController.text),
                            child: const Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Icon(
                                  CupertinoIcons
                                      .chevron_left_slash_chevron_right,
                                ),
                                SizedBox(width: 4),
                                Text('Apply Raw Filter & Close'),
                              ],
                            ),
                          ),
                        ),
                        // Help Section
                        _buildHelpSection(context),
                        // Add some bottom padding inside the scroll view
                        const SizedBox(height: 30),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }


  // Updated _buildTagChip to remove isDarkMode parameter and use context for theme
  Widget _buildTagChip(String tag) {
    final theme = CupertinoTheme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: CupertinoColors.secondarySystemFill.resolveFrom(context),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            tag,
            style: theme.textTheme.textStyle.copyWith(fontSize: 14),
          ),
          const SizedBox(width: 4),
          CupertinoButton(
            padding: EdgeInsets.zero,
            minSize: 0,
            onPressed: () => _removeTag(tag),
            child: Icon(
              CupertinoIcons.clear_circled_solid,
              size: 16,
              color: CupertinoColors.secondaryLabel.resolveFrom(context),
            ),
          ),
        ],
      ),
    );
  }

  // REMOVED: _showTimeRangePicker method

  // Updated _buildPresetChip for better Cupertino styling
  Widget _buildPresetChip(String key, String label) {
    final isSelected = _selectedPreset == key;
    final theme = CupertinoTheme.of(context);
    final Color backgroundColor = isSelected
        ? theme.primaryColor
        : CupertinoColors.secondarySystemFill.resolveFrom(context);
    final Color textColor = isSelected
        ? CupertinoColors.white // Or theme.primaryContrastingColor if defined
        : CupertinoColors.label.resolveFrom(context);

    return CupertinoButton(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      minSize: 0,
      borderRadius: BorderRadius.circular(16),
      color: backgroundColor,
      onPressed: () {
        // Apply the preset from this panel
        _applyPreset(key);
      },
      child: Text(
        label,
        style: theme.textTheme.textStyle.copyWith(
          fontSize: 14,
          color: textColor,
        ),
      ),
    );
  }

  Widget _buildCodeExample(String code) {
    // Use CupertinoTheme to determine dark mode
    final isDarkMode = CupertinoTheme.of(context).brightness == Brightness.dark;
    final Color codeBackgroundColor = isDarkMode
        ? CupertinoColors.darkBackgroundGray
        : CupertinoColors.extraLightBackgroundGray;
    // Use Cupertino dynamic colors for text if possible, or define specific ones
    final Color codeTextColor = CupertinoColors.label.resolveFrom(
      context,
    ); // Use label color


    return Padding(
      padding: const EdgeInsets.only(bottom: 4),
      child: CupertinoButton(
        padding: EdgeInsets.zero,
        onPressed: () {
          _rawFilterController.text = code;
          // Optionally validate before applying
          _validateFilter();
          // Apply the raw filter (which also closes the panel)
          // _applyFilter(code); // Commented out: Let user click Apply Raw Filter button
        },
        child: Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: codeBackgroundColor,
            borderRadius: BorderRadius.circular(4),
          ),
          child: Text(
            code,
            style: TextStyle(
              fontFamily: 'monospace',
              fontSize: 13,
              color: codeTextColor,
            ),
          ),
        ),
      ),
    );
  }

  bool _showHelp = false;

  // Updated _buildHelpSection to remove isDarkMode parameter
  Widget _buildHelpSection(BuildContext context) {
    // final theme = CupertinoTheme.of(context); // Unused
    return Container(
      margin: const EdgeInsets.only(top: 16.0, bottom: 16.0),
      decoration: BoxDecoration(
        color: CupertinoColors.secondarySystemGroupedBackground.resolveFrom(context),
        borderRadius: BorderRadius.circular(8.0),
      ),
      child: Column(
        children: [
          CupertinoListTile(
            title: const Text('Filter Syntax Help'),
            trailing: CupertinoButton(
              padding: EdgeInsets.zero,
              minSize: 0,
              onPressed: () => setState(() => _showHelp = !_showHelp),
              child: Icon(
                _showHelp ? CupertinoIcons.chevron_up : CupertinoIcons.chevron_down,
                size: 20,
                color: CupertinoColors.secondaryLabel.resolveFrom(context),
              ),
            ),
            onTap: () => setState(() => _showHelp = !_showHelp),
          ),
          if (_showHelp)
            Padding(
              padding: const EdgeInsets.only(left: 16, right: 16, bottom: 16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Common Filter Patterns:',
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),
                  _buildCodeExample('tag in ["work", "important"]'),
                  _buildCodeExample('visibility == "PUBLIC"'),
                  _buildCodeExample('content.contains("meeting")'),
                  _buildCodeExample('create_time > "2023-01-01T00:00:00Z"'),
                  const SizedBox(height: 16),
                  const Text(
                    'Combine with && (AND) or || (OR):',
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),
                  _buildCodeExample(
                    'tag in ["work"] && visibility == "PUBLIC"',
                  ),
                  _buildCodeExample(
                    'content.contains("urgent") || content.contains("important")',
                  ),
                  const SizedBox(height: 16),
                  const Text(
                    'Negate with ! (NOT):',
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),
                  _buildCodeExample('!content.contains("draft")'),
                ],
              ),
            ),
        ],
      ),
    );
  }
}

// SyntaxHighlightTextField and helpers remain unchanged for now
// TODO: Refactor SyntaxHighlightTextField to fully use Cupertino styles and avoid Material dependencies.
// This is a placeholder refactor, focusing on replacing the TextField.
// Proper syntax highlighting color mapping to Cupertino dynamic colors is needed.
class SyntaxHighlightTextField extends StatefulWidget {
  final TextEditingController controller;
  // final InputDecoration decoration; // Removed Material InputDecoration
  final Function(String)? onChanged;
  final int? maxLines;
  final TextStyle? style; // Keep style for font family etc.
  final String? placeholder; // Add placeholder

  const SyntaxHighlightTextField({
    super.key,
    required this.controller,
    // this.decoration = const InputDecoration(),
    this.onChanged,
    this.maxLines,
    this.style,
    this.placeholder,
  });

  @override
  State<SyntaxHighlightTextField> createState() =>
      _SyntaxHighlightTextFieldState();
}

class _SyntaxHighlightTextFieldState extends State<SyntaxHighlightTextField> {
  @override
  void initState() {
    super.initState();
    widget.controller.addListener(_handleTextChanged);
  }

  @override
  void dispose() {
    widget.controller.removeListener(_handleTextChanged);
    super.dispose();
  }

  void _handleTextChanged() {
    // Trigger rebuild to update RichText
    if (mounted) {
      setState(() {}); // Need setState to trigger RichText rebuild
    }
    // Call user's onChanged callback if provided
    widget.onChanged?.call(widget.controller.text);
  }

  // Placeholder: Needs proper mapping to Cupertino dynamic colors
  List<TextSpan> _buildHighlightedSpans(String text, BuildContext context) {
     final theme = CupertinoTheme.of(context);
    // No need for isDarkMode as colors automatically adapt with resolveFrom(context)

     // Define colors based on Cupertino theme (example mapping)
     final Color operatorColor = CupertinoColors.systemOrange.resolveFrom(context);
     final Color keywordColor = CupertinoColors.systemBlue.resolveFrom(context);
     final Color stringColor = CupertinoColors.systemGreen.resolveFrom(context);
     final Color normalColor = CupertinoColors.label.resolveFrom(context);
     final Color functionColor = CupertinoColors.systemPurple.resolveFrom(context);
     final Color commentColor = CupertinoColors.secondaryLabel.resolveFrom(context); // Example for comments
    final Color numberColor = CupertinoColors.systemRed.resolveFrom(
      context,
    ); // Example for numbers

    // Regex remains the same, added number regex
    final operatorRegex = RegExp(r'&&|\|\||!|==|!=|<=|>=|<|>|\bin\b'); // Added word boundary for 'in'
    final keywordRegex = RegExp(
      r'\b(tag|visibility|create_time|update_time|state|content|true|false|null)\b',
    );
    final doubleQuoteStringRegex = RegExp(r'"(?:[^"\\]|\\.)*"');
    final singleQuoteStringRegex = RegExp(r"'(?:[^'\\]|\\.)*'");
    final functionRegex = RegExp(
      r'\b(contains|size|startsWith|endsWith)\b(?=\()',
    );
    final commentRegex = RegExp(r'//.*');
    final numberRegex = RegExp(r'\b\d+(\.\d+)?\b'); // Basic number regex

    List<TextSpan> spans = [];
    int currentPosition = 0;

    void addSpan(int start, int end, Color color) {
      if (start < end) {
        final baseStyle = widget.style ?? theme.textTheme.textStyle;
        spans.add(
          TextSpan(
            text: text.substring(start, end),
            style: baseStyle.copyWith(color: color),
          ),
        );
      }
    }

    List<_HighlightMatch> matches = [];
    operatorRegex
        .allMatches(text)
        .forEach((m) => matches.add(_HighlightMatch(m, operatorColor)));
    keywordRegex
        .allMatches(text)
        .forEach((m) => matches.add(_HighlightMatch(m, keywordColor)));
    doubleQuoteStringRegex
        .allMatches(text)
        .forEach((m) => matches.add(_HighlightMatch(m, stringColor)));
    singleQuoteStringRegex
        .allMatches(text)
        .forEach((m) => matches.add(_HighlightMatch(m, stringColor)));
    functionRegex
        .allMatches(text)
        .forEach((m) => matches.add(_HighlightMatch(m, functionColor)));
    commentRegex
        .allMatches(text)
        .forEach((m) => matches.add(_HighlightMatch(m, commentColor)));
    numberRegex
        .allMatches(text)
        .forEach(
          (m) => matches.add(_HighlightMatch(m, numberColor)),
        ); // Add number matches

    matches.sort((a, b) => a.match.start.compareTo(b.match.start));

    // Process matches and add spans, handling overlaps simply by taking the first match
    int lastMatchEnd = 0;
    for (var highlight in matches) {
      // Skip overlapping matches
      if (highlight.match.start < lastMatchEnd) continue;

      // Add normal text before the current match
      if (highlight.match.start > currentPosition) {
        addSpan(currentPosition, highlight.match.start, normalColor);
      }
      // Add the highlighted match itself
      addSpan(highlight.match.start, highlight.match.end, highlight.color);
      currentPosition = highlight.match.end;
      lastMatchEnd = highlight.match.end; // Update last match end
    }

    // Add any remaining normal text after the last match
    if (currentPosition < text.length) {
      addSpan(currentPosition, text.length, normalColor);
    }

    if (spans.isEmpty && text.isEmpty) {
      final baseStyle = widget.style ?? theme.textTheme.textStyle;
       spans.add(TextSpan(text: '', style: baseStyle));
    }

    return spans;
  }

  @override
  Widget build(BuildContext context) {
    final theme = CupertinoTheme.of(context);
    final defaultTextStyle = widget.style ?? theme.textTheme.textStyle.copyWith(
      fontFamily: 'monospace',
      fontSize: 14,
    );

    // Build highlighted spans based on current text
    final spans = _buildHighlightedSpans(widget.controller.text, context);

    return Stack(
      children: [
        // Background RichText for syntax highlighting
        // Use Padding to align with CupertinoTextField's internal padding
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 6.0, horizontal: 8.0), // Approximate default padding
          child: RichText(
            text: TextSpan(
              children: spans,
              style: defaultTextStyle, // Base style for the TextSpan
            ),
            maxLines: widget.maxLines,
            overflow: TextOverflow.clip, // Or handle overflow as needed
          ),
        ),
        // Transparent CupertinoTextField for input
        CupertinoTextField(
          controller: widget.controller,
          padding: const EdgeInsets.symmetric(vertical: 6.0, horizontal: 8.0), // Match RichText padding
          placeholder: widget.placeholder,
          maxLines: widget.maxLines,
          // onChanged is handled by the listener calling widget.onChanged
          // Make the text transparent to see the RichText underneath
          style: defaultTextStyle.copyWith(color: CupertinoColors.transparent),
          // Remove default CupertinoTextField border/background
          decoration: const BoxDecoration(
            color: CupertinoColors.transparent,
          ),
          // Ensure keyboard type allows multiple lines if needed
          keyboardType: widget.maxLines != 1 ? TextInputType.multiline : TextInputType.text,
          // Add autocorrect and spellcheck disabling for code-like input
          autocorrect: false,
          enableSuggestions: false,
          smartDashesType: SmartDashesType.disabled,
          smartQuotesType: SmartQuotesType.disabled,
        ),
      ],
    );
  }
}

// Helper class for sorting matches
class _HighlightMatch {
  final RegExpMatch match;
  final Color color;
  _HighlightMatch(this.match, this.color);
}

// Removed unused _Token class

extension StringExtension on String {
  String capitalizeFirstLetter() {
    if (isEmpty) return this;
    return this[0].toUpperCase() + substring(1);
  }
}
